import { Callout } from 'nextra/components'

# Coding Standards

<Callout type="warning">Docs for coding standards are under construction.</Callout>

The coding standards below are mostly referenced from [Airbnb's JavaScript Style Guide](https://airbnb.io/javascript/react/#naming) and [Google's TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html#identifiers-constants).

While some of the coding standards are handled by Prettier and ESLint, there are some rules that are not covered by these tools. This article will cover those rules.

## General Principles

Keep in mind the following principles when writing code:

- **Consistency**: Maintain consistent naming conventions, formatting, and coding styles throughout the codebase.

- **Readability**: Write code that is easy to read and understand. Use meaningful variable and function names.

- **Simplicity**: Write simple code that is easy to understand and maintain. Avoid unnecessary complexity.

- **Modularity**: Break down your code into small, reusable components and modules. Aim for single-responsibility components.

## General Coding

### Naming Conventions

#### Identifier Syntax

The following table summarizes the naming conventions of the sections below. Read the sections for more details.

import { OptionTable } from 'components/table'

<OptionTable
  options={[
    ['PascalCase', 'class / interface / type / enum / decorator / type parameters'],
    ['camelCase', 'variable / parameter / function / method / property / module alias'],
    ['ALL_CAPS_SNAKE_CASE', 'global constant values, including enum values.'],
    ['kebab-case', 'id / class / file / folder / file path'],
  ]}
  customHead={{
    option: 'Style',
    description: 'Category',
  }}
  hasType={false}
/>

<Callout>
  While this table only shows the format for naming, it does not show how to name the actual
  identifier. For this, take note of the following:
- Use [S-I-D](/getting-started/primer/naming#s-i-d) technique. Names should be detailed enough that one immediately recognizes what the variable/function is used for.
- Use ubiquitous language when naming variables/functions.

</Callout>

#### Files and Folders

This section covers the naming conventions for files and folders.

<OptionTable
  options={[
    ['PascalCase', 'components'],
    ['camelCase', 'hooks'],
    ['kebab-case', 'assets', 'Next.js pages and API routes'],
    ['ALL_CAPS_SNAKE_CASE', 'miscellaneous'],
  ]}
  customHead={{
    option: 'Style',
    description: 'Category',
  }}
  hasType={false}
/>

- Assets must be in `<page>-<shortdescription>.png` format. For example, `home-hero.png`.

- **File paths** in `import` must be **case-sensitive**.

```js
// For example, the file name is `arrowRight.png`

// Good
import ArrowRight from 'assets/images/arrowRight.png'

// Avoid
import ArrowRight from 'assets/images/arrowright.png'
```

<Callout type="info">
  Fortunately for this example, the casing for assets files are in kebab-case. However, it's still
  good to be aware of this. This is to avoid issues when deploying to Linux servers (which Vercel
  uses).
</Callout>

### Comments

Use comments to explain complex logic, non-obvious code, or any workarounds.

## React

### Component Naming

Use PascalCase for component names. For example, `Header`, `UserProfile`.

```jsx
// Good
function UserProfile() {
  // ...
}

// Avoid
function user_profile() {
  // ...
}
```

### Functional Components

Use functional components as the default.

```jsx
// Good
function App() {
  // ...
}

// Avoid
class App extends React.Component {
  // ...
}
```

### Props Naming

Use camelCase for prop names. Make prop names descriptive.

```jsx
// Good
function Avatar({ imageUrl }) {
  // ...
}

// Avoid
function Avatar({ img_url }) {
  // ...
}
```

### Component Structure

Organize components with a clear hierarchy. Use JSX fragments (`<>...</>`) when returning multiple elements.

```jsx
// Good
function UserProfile() {
  return (
    <>
      <Header />
      <UserInfo />
      <UserPosts />
    </>
  )
}
// Avoid
function UserProfile() {
  return (
    // only use div if necessary such as styling
    <div>
      <Header />
      <UserInfo />
      <UserPosts />
    </div>
  )
}
```

## TypeScript

### Type Annotations

Use TypeScript's type annotations for variables, function arguments, and return types. This enhances code clarity and catch errors early.

### Interfaces and Types

Use interfaces for defining object structures and types for simple cases. Use union types, intersection types, etc., as needed.

### Type Inference

Leverage TypeScript's type inference but add explicit types when necessary.

## Tailwind CSS

### Class Names

Use utility classes provided by Tailwind CSS for styling. Create custom classes only when necessary.

### Responsive Design

Utilize Tailwind's responsive classes for building responsive layouts.

### Separation of Concerns

Keep layout and styles separate from logic in components. Avoid inline styles when possible.

## Prisma

### Naming Conventions

Follow naming conventions for models, fields, and relationships as per Prisma's guidelines.

### Data Modeling

Design clear and consistent data models. Use appropriate data types and relationships.

### Migration Scripts

Use Prisma's migration scripts to manage database schema changes. Document migrations for better understanding.

## TSX

1. When naming id and classes with more than one word, use **kebab-case** (hyphen).

   Example: `#about-me`, `.container-head`

2. Avoid shortening words as much as possible (e.g., 'details' to 'det') or using one-letter names (e.g., `#i`, or `.c`).

## CSS

1. **Grouping and Comments**:

Add a comment to group structures/blocks.

Example:

```css
/* classes */
.container {
  margin: 0;
}
```

2. **Multiple Selectors**:

   If multiple selectors are used (`,`), enter on a newline for each selector.

   Example:

   ```css
   .username,
   .profile-pic {
     margin: 0;
   }
   ```

---

## Next.js and React

1. **File Structure and Naming**:

   - Organize components, pages, and utilities into separate folders.
   - Use PascalCase for component and page filenames (e.g., `Header.js`, `HomePage.js`).
   - Group related components and files together.

2. **Component Naming**:

   - Use descriptive and meaningful names for components.
   - Use PascalCase for component names (e.g., `Header`, `UserProfile`).

3. **Component Structure**:

   - Follow a consistent component structure with props, state (if needed), render logic, and lifecycle methods (if used).

4. **JSX and Formatting**:

   - Use JSX for rendering components.
   - Format JSX content with proper indentation for better readability.
   - Avoid unnecessary nesting of components.

5. **Props**:

   - Use destructuring for accessing props in functional components.
   - Clearly define and document prop types using PropTypes or TypeScript.

6. **State Management**:
   - Use React's state management or external libraries like Redux based on project complexity.
   - Use functional components and hooks (useState, useEffect, etc.) for managing state.

## Tailwind CSS

1. **Class Naming**:

   - Utilize Tailwind CSS's utility classes for styling components.
   - Aim to use utility classes for common styling tasks.
   - Define custom utility classes when necessary.

2. **Component Styling**:

   - Keep styling classes close to their respective components.
   - Avoid inline styles unless required.

3. **Responsive Design**:

   - Use Tailwind's responsive classes to create mobile-friendly layouts.

4. **Custom Styling**:
   - Define custom CSS classes in the project's stylesheet when utility classes don't suffice.
