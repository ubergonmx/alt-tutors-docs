import { Callout } from 'nextra/components'

# Coding Standards

<Callout type="warning">Docs for coding standards are under construction.</Callout>

Most of the coding standards are handled by Prettier and ESLint. However, there are some rules that are not covered by these tools. This document will cover those rules.

## General coding

1. **Space Conventions**:

   - Each nested block has to be spaced and indented appropriately.
   - A space is required after adding a comma separating two function parameters.

   Example: `method1(arg1, arg2)`, `app.use((req, res, err) =>..`

2. **Naming Conventions**:

   - **Functions** must be in **camelCase**.
   - **Variables**:

     - **Local & Parameter** variables must be in **camelCase**.
     - **Global** variables must be in **PascalCase**.
     - **Constant** variables must be in **UPPERCASE**.

   - **Files**:

     - **Schema** files must be in **PascalCase**.
     - **Controller** and `.hbs` files must be in **camelCase**.
     - **File paths** in `import` must be **case-sensitive**.
     - Front end files must be the same (e.g., `index.hbs`, `index.css`, `index.js`).

   - Names should be detailed enough that one immediately recognizes what the variable/function is used for. Use nouns & verbs of the business domain as identifiers for methods & variables.

3. **Error Messages**:

   Error messages must be clear and concise.

4. **Code Style**:

   Donâ€™t write in ALL CAPS (and avoid exclamation marks). Always document your code.

## TSX

1. When naming id and classes with more than one word, use **kebab-case** (hyphen).

   Example: `#about-me`, `.container-head`

2. Avoid shortening words as much as possible (e.g., 'details' to 'det') or using one-letter names (e.g., `#i`, or `.c`).

## CSS

1. **Grouping and Comments**:

   Add a comment to group structures/blocks.

   Example:

   ```css
   /* classes */
   .container {
       margin: 0;
   }
   ...
   ```

2. **Multiple Selectors**:

   If multiple selectors are used (`,`), enter on a newline for each selector.

   Example:

   ```css
   .username,
   .profile-pic {
     margin: 0;
   }
   ```

---

### Next.js and React:

1. **File Structure and Naming**:

   - Organize components, pages, and utilities into separate folders.
   - Use PascalCase for component and page filenames (e.g., `Header.js`, `HomePage.js`).
   - Group related components and files together.

2. **Component Naming**:

   - Use descriptive and meaningful names for components.
   - Use PascalCase for component names (e.g., `Header`, `UserProfile`).

3. **Component Structure**:

   - Follow a consistent component structure with props, state (if needed), render logic, and lifecycle methods (if used).

4. **JSX and Formatting**:

   - Use JSX for rendering components.
   - Format JSX content with proper indentation for better readability.
   - Avoid unnecessary nesting of components.

5. **Props**:

   - Use destructuring for accessing props in functional components.
   - Clearly define and document prop types using PropTypes or TypeScript.

6. **State Management**:
   - Use React's state management or external libraries like Redux based on project complexity.
   - Use functional components and hooks (useState, useEffect, etc.) for managing state.

### Tailwind CSS:

1. **Class Naming**:

   - Utilize Tailwind CSS's utility classes for styling components.
   - Aim to use utility classes for common styling tasks.
   - Define custom utility classes when necessary.

2. **Component Styling**:

   - Keep styling classes close to their respective components.
   - Avoid inline styles unless required.

3. **Responsive Design**:

   - Use Tailwind's responsive classes to create mobile-friendly layouts.

4. **Custom Styling**:
   - Define custom CSS classes in the project's stylesheet when utility classes don't suffice.

### Prisma:

1. **Database Schema**:

   - Use PascalCase for model names (e.g., `User`, `Post`).
   - Define relationships between models using appropriate fields (e.g., `User.posts`).

2. **Queries and Mutations**:

   - Use Prisma's query and mutation methods to interact with the database.
   - Utilize filtering, pagination, and sorting options to efficiently retrieve data.

3. **Transactions and Error Handling**:

   - Use transactions to ensure data consistency in complex operations.
   - Implement error handling for database operations.

4. **Migrations**:
   - Use migrations to manage changes to the database schema.
   - Document migration steps for team members.
